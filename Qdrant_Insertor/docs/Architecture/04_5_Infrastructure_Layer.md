# 4.5 基础设施层

## 2.1 概述

基础设施层包含了所有具体的、技术性的实现细节，例如数据库操作、文件系统访问、外部服务调用、日志记录等。本层是领域层和应用层的支撑，提供了实现业务逻辑所需的技术能力，但其实现细节对上层是透明的。

## 2.2 模块列表

- **SQLiteRepo**
- **QdrantRepo**
- **FileLoader**
- **Splitter**
- **EmbeddingProvider**
- **GraphRepo Impl.**
- **Winston Logger**
- **Pagination Utils**

## 2.3 模块详情

### 2.3.1 SQLiteRepo

#### 2.3.1.1 职责

- **元数据持久化**：负责与 SQLite 数据库进行交互，实现 `Collection`、`Doc`、`Chunk` 等元数据的 CRUD 操作。
- **全文搜索**：提供基于 FTS5 的关键词搜索能力。
- **数据一致性**：为 `SyncStateMachine` 和 `AutoGC` 提供数据查询和修改接口，以维护数据一致性。

#### 2.3.1.2 接口与数据流

- **对外接口**：由应用层 (如 `ImportService`, `SearchService`, `AutoGC`) 和领域层 (如 `Retriever`) 调用。
- **对内接口**：直接与 `better-sqlite3` 库交互。
- **数据流**：Application/Domain Layer -> SQLiteRepo -> SQLite Database。

#### 2.3.1.3 关键实现与技术栈

- **技术栈**：`better-sqlite3`。
- **Schema 管理**：数据库表结构定义和迁移。
- **事务管理**：确保数据操作的原子性。
- **FTS5**：实现全文搜索索引和查询。

#### 2.3.1.4 开发需求与约定

- **编码规范**：
  - SQL 语句应清晰、安全，避免 SQL 注入。
  - 数据库操作应封装在独立的 Repository 方法中。
- **错误处理**：
  - 捕获数据库操作异常，并转换为统一的错误类型。
  - 记录数据库操作日志，便于问题排查。
- **测试策略**：
  - 对 `SQLiteRepo` 进行单元测试，验证 CRUD 操作和 FTS5 搜索的正确性。
  - 使用内存数据库进行测试，提高测试效率。
- **性能考量**：
  - 优化 SQL 查询，确保索引的有效使用。
  - 批量插入和更新操作。
- **安全考量**：
  - 数据库文件权限管理。

### 2.3.2 QdrantRepo

#### 2.3.2.1 职责

- **对接 Qdrant 向量数据库**：负责与 Qdrant 向量数据库进行交互，实现向量的插入、更新、删除和搜索。
- **向量存储与检索**：存储文本块的向量表示及其 `payload`（元数据），并支持高效的向量相似度搜索。

#### 2.3.2.2 接口与数据流

- **对外接口**：由应用层 (如 `ImportService`, `AutoGC`) 和领域层 (如 `Retriever`) 调用。
- **对内接口**：直接与 `qdrant-client` 库交互。
- **数据流**：Application/Domain Layer -> QdrantRepo -> Qdrant Database。

#### 2.3.2.3 关键实现与技术栈

- **技术栈**：`qdrant-client`。
- **Collection 管理**：创建、配置和删除 Qdrant Collection。
- **向量操作**：批量 upsert (插入/更新) 向量和 `payload`。
- **相似度搜索**：执行向量相似度搜索，支持 `payload` 过滤。

#### 2.3.2.4 开发需求与约定

- **编码规范**：
  - Qdrant 操作应封装在独立的 Repository 方法中。
  - 确保 `payload` 结构与元数据定义一致。
- **错误处理**：
  - 捕获 Qdrant 客户端异常，并进行适当的日志记录。
- **测试策略**：
  - 对 `QdrantRepo` 进行集成测试，验证向量操作和搜索的正确性。
  - 在测试环境中模拟 Qdrant 服务。
- **性能考量**：
  - 优化批量操作，减少网络往返次数。
  - 关注 Qdrant 索引配置和硬件资源。
- **安全考量**：
  - Qdrant 访问权限和认证。

### 2.3.3 FileLoader

#### 2.3.3.1 职责

- **支持纯文本格式加载**：负责从文件系统加载原始文档内容，支持 TXT、Markdown 等纯文本格式。
- **抽象文件读取**：封装了不同文件格式的读取细节，向上层提供统一的文档内容获取接口。

#### 2.3.3.2 接口与数据流

- **对外接口**：由 `ImportService` 调用，接收文件路径或文件流。
- **对内接口**：使用 Node.js 内置的 `fs` 模块读取文件。
- **数据流**：ImportService -> FileLoader -> File System。

#### 2.3.3.3 关键实现与技术栈

- **文件读取**：使用 UTF-8 编码读取纯文本文件内容。
- **MIME 类型检测**：使用 `mime-types` 库检测文件类型。

#### 2.3.3.4 开发需求与约定

- **编码规范**：
  - 文件加载逻辑应具有良好的扩展性，便于未来支持更多文件格式。
- **错误处理**：
  - 处理文件不存在、文件损坏或解析失败等异常情况。
- **测试策略**：
  - 对 `FileLoader` 进行单元测试，验证其对不同文件格式的正确加载和文本提取能力。
- **性能考量**：
  - 处理大文件时，考虑流式读取和分块处理。

### 2.3.4 Splitter

#### 2.3.4.1 职责

- **文本切片策略**：将原始文档内容分割成更小、更易于处理的文本块（Chunks），并提取相关元数据。
- **支持多种分割策略**：按段落、字符、语义等多种策略进行切片。

#### 2.3.4.2 接口与数据流

- **对外接口**：由 `ImportService` 调用，接收文档内容和分割选项。
- **对内接口**：无直接对内接口，可能依赖文本处理工具。
- **数据流**：ImportService -> Splitter -> ImportService。

#### 2.3.4.3 关键实现与技术栈

- **文本处理**：实现各种文本分割算法。
- **元数据提取**：在分割过程中保留 `titleChain` 等上下文信息。

#### 2.3.4.4 开发需求与约定

- **编码规范**：
  - 分割策略应可配置，并易于扩展新的策略。
  - 确保分割后的块具有语义连贯性。
- **错误处理**：
  - 处理文本内容为空或分割失败的情况。
- **测试策略**：
  - 对 `Splitter` 进行单元测试，验证不同分割策略在各种文本输入下的正确性。
- **性能考量**：
  - 优化文本分割算法的效率，尤其是在处理长文档时。

### 2.3.5 EmbeddingProvider

#### 2.3.5.1 职责

- **调用 OpenAI/HuggingFace 接口生成向量**：封装了与外部 Embedding 服务（如 OpenAI、HuggingFace）的交互，将文本内容转换为高维向量。
- **抽象 Embedding 服务**：提供统一的 Embedding 生成接口，允许轻松切换不同的 Embedding 服务提供商。

#### 2.3.5.2 接口与数据流

- **对外接口**：由 `ImportService` 调用，接收文本内容。
- **对内接口**：与外部 Embedding API 进行 HTTP 请求。
- **数据流**：ImportService -> EmbeddingProvider -> External Embedding Service。

#### 2.3.5.3 关键实现与技术栈

- **HTTP 客户端**：Axios, Fetch API 等。
- **API 封装**：封装 OpenAI 兼容的 API 请求和响应。
- **批量请求**：支持批量文本的向量化请求，提高效率。

#### 2.3.5.4 开发需求与约定

- **编码规范**：
  - Embedding 服务接口应具有可插拔性，便于替换不同的提供商。
  - API Key 等敏感信息应通过环境变量配置。
- **错误处理**：
  - 处理外部 API 调用失败、限速或返回错误的情况。
  - 实现重试和指数退避策略。
- **测试策略**：
  - 对 `EmbeddingProvider` 进行集成测试，验证与外部 Embedding 服务的正确交互。
  - 使用 Mock 对象模拟外部 API 响应，进行单元测试。
- **性能考量**：
  - 优化批量请求，减少 API 调用次数。
  - 关注外部 API 的限速策略。
- **安全考量**：
  - 保护 API Key 等敏感凭证。

### 2.3.6 GraphRepo Impl. (长期目标)

#### 2.3.6.1 职责

- **基于内存或 Neo4j 的图存储实现**：实现 `GraphRepository Interface` 定义的图存储抽象接口。此模块为未来扩展知识图谱能力预留，当前可能处于规划或初步实现阶段。
- **具体技术实现**：根据选择的图数据库技术（如内存、Neo4j），完成图数据的持久化和查询。

#### 2.3.6.2 接口与数据流

- **对外接口**：实现 `GraphRepository Interface`。
- **对内接口**：与具体的图数据库（如 Neo4j 客户端库）交互。
- **数据流**：Domain Layer (GraphRepository Interface) -> GraphRepo Impl. -> Graph Database。

#### 2.3.6.3 关键实现与技术栈

- **技术栈**：内存数据结构或 `neo4j-driver`。
- **数据映射**：将领域层的 `GraphFragment` 映射到图数据库的存储结构。

#### 2.3.6.4 开发需求与约定

- **编码规范**：
  - 实现应严格遵循 `GraphRepository Interface` 的契约。
  - 图数据库操作应封装在独立的 Repository 方法中。
- **错误处理**：
  - 捕获图数据库操作异常，并转换为领域层友好的错误类型。
- **测试策略**：
  - 对 `GraphRepo Impl.` 进行集成测试，验证其与图数据库的正确交互。
- **性能考量**：
  - 优化图查询和存储操作的效率。

### 2.3.7 Winston Logger

#### 2.3.7.1 职责

- **结构化日志输出**：提供统一的日志记录功能，支持输出到控制台和日志文件。
- **分级别输出**：支持 debug/info/warn/error 等不同级别的日志输出。
- **错误上报**：自动将错误日志上报至 Sentry 等监控服务。

#### 2.3.7.2 接口与数据流

- **对外接口**：由应用层和基础设施层中的其他模块调用，进行日志记录。
- **对内接口**：与 `winston` 库和 `sentry` 客户端交互。
- **数据流**：Application/Infrastructure Layer -> Winston Logger -> Console / Log File / Sentry。

#### 2.3.7.3 关键实现与技术栈

- **技术栈**：`winston`。
- **传输器 (Transports)**：配置 Console Transport 和 File Transport。
- **格式化 (Formatters)**：结构化日志输出 (JSON)。
- **Sentry 集成**：使用 `winston-sentry` 或自定义插件集成 Sentry。

#### 2.3.7.4 开发需求与约定

- **编码规范**：
  - 日志记录应使用统一的 Logger 实例。
  - 日志消息应具有描述性，包含必要的上下文信息。
- **错误处理**：
  - 确保日志系统本身的健壮性，避免日志记录失败影响主业务流程。
- **测试策略**：
  - 对 `Winston Logger` 进行单元测试，验证其日志输出格式和级别过滤的正确性。
- **性能考量**：
  - 优化日志写入性能，避免阻塞主线程。
- **安全考量**：
  - 避免在日志中记录敏感信息。
  - 日志文件权限管理。

### 2.3.8 Pagination Utils

#### 2.3.8.1 职责

- **统一分页处理**：提供统一的分页查询参数解析和响应格式化功能。
- **分页验证**：验证分页参数的有效性，确保页码和限制值在合理范围内。
- **SQL 分页支持**：生成 SQL 查询的分页子句，支持排序和偏移。
- **分页元数据计算**：计算总页数、是否有下一页等分页导航信息。

#### 2.3.8.2 接口与数据流

- **对外接口**：由应用层和 API 层调用，提供分页处理功能。
- **对内接口**：无直接对内接口，作为工具函数使用。
- **数据流**：Application/API Layer -> Pagination Utils -> Formatted Response。

#### 2.3.8.3 关键实现与技术栈

- **分页配置**：定义默认页码、默认限制和最大限制等配置。
- **参数解析**：解析和验证查询参数中的分页信息。
- **SQL 生成**：生成 LIMIT、OFFSET 和 ORDER BY 子句。

#### 2.3.8.4 开发需求与约定

- **编码规范**：
  - 分页参数命名应保持一致性（page、limit、sort、order）。
  - 分页响应格式应统一，包含数据和元数据。
- **错误处理**：
  - 处理无效的分页参数，返回友好的错误信息。
  - 处理超出范围的页码，返回空结果或适当的错误。
- **测试策略**：
  - 对分页工具进行单元测试，验证参数解析和 SQL 生成的正确性。
  - 测试边界情况，如最大限制、负数页码等。
- **性能考量**：
  - 优化分页查询，避免深度分页性能问题。
  - 考虑使用游标分页替代偏移分页，提高大数据量下的性能。
