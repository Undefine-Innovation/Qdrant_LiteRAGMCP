# 当前架构与面临的问题

## 1. 实际使用的架构概述

当前的系统架构如 `docs/Architecture_Overview.md` 中所述，是一个基于 Qdrant 和 SQLite 的 RAG 系统。其核心思想是通过 REST API 暴露功能，内部依赖于文档加载、分割、向量化、Qdrant 向量存储和 SQLite 元数据存储，并通过搜索服务进行混合检索。

### 1.1 核心模块职责

- **API 层 (`backend/src/api.ts`)**: 负责接收 HTTP 请求，并直接协调底层模块（DB、Qdrant、Embedding、Splitter）的操作。
- **数据层**:
  - **SQLite (`backend/src/db.ts`)**: 存储 Collection、Version、Doc、ChunkMeta 等元数据，并提供 FTS5 关键词搜索。
  - **Qdrant (`backend/src/qdrant.ts`)**: 存储文本块的向量表示，支持语义搜索。
- **处理层**:
  - **Loader (`backend/src/loader.ts`)**: 加载原始文档。
  - **Splitter (`backend/src/splitter.ts`)**: 分割文档为文本块。
  - **Embedding (`backend/src/embedding.ts`)**: 生成文本块的向量。
- **搜索层 (`backend/src/search.ts`)**: 结合关键词和语义搜索，融合结果。

### 1.2 启动协调 (`backend/src/index.ts`)

目前，`backend/src/index.ts` 承担了多重职责，包括配置加载、API 服务启动、Qdrant 集合初始化以及后台文档处理循环（加载、分割、嵌入、upsert 到 Qdrant）。它直接协调了所有底层模块。

## 2. 面临的问题与挑战

### 2.1 模块耦合度高，缺乏中间抽象层

- **问题描述**: `backend/src/api.ts` 作为 API 层，直接调用了 `db.ts`, `qdrant.ts`, `embedding.ts`, `splitter.ts` 等多个底层模块的功能。这导致 `api.ts` 文件庞大且复杂，包含了大量的业务逻辑编排，使得代码难以理解、测试和维护。
- **影响**:
  - **可维护性差**: 任何底层模块的变更都可能影响到 `api.ts`，反之亦然。
  - **可测试性差**: 难以对 `api.ts` 中的业务逻辑进行单元测试，因为它与多个外部依赖紧密耦合。
  - **可扩展性差**: 难以引入新的业务流程或替换底层实现，因为需要修改 `api.ts` 中的大量代码。
  - **职责不清晰**: `api.ts` 既处理 HTTP 请求，又处理业务逻辑，职责边界模糊。

### 2.2 `index.ts` 职责过重

- **问题描述**: `backend/src/index.ts` 不仅负责启动 API 服务，还直接管理后台文档处理的整个生命周期，包括文档加载、分割、嵌入和 Qdrant upsert。这种设计使得 `index.ts` 成为一个“大杂烩”，难以管理和扩展。
- **影响**:
  - **启动逻辑复杂**: 启动时需要协调所有模块，增加了启动过程的复杂性。
  - **后台任务管理困难**: 后台文档处理逻辑与主应用启动逻辑混杂，难以独立部署或扩展后台任务。

### 2.3 `Version` 概念的重新讨论

- **问题描述**: 当前的 `Version` 设计旨在提供严格的版本控制，通过 `finalizeVersion` 机制创建不可变的、内容哈希的版本。然而，这带来了一些实际操作上的挑战和用户体验问题：
  - **文档更新的复杂性**: 当用户需要更新文档内容时，当前的 `updateDoc` 逻辑会删除旧的 Qdrant 向量并插入新的。这个过程在 Qdrant 层面是“昂贵”且“麻烦”的，尤其是在高频更新的场景下。
  - **用户体验与期望不符**: 用户可能不希望每次修改都创建一个新的“严格版本”。他们可能更倾向于：
    - **追加文档**: 在现有版本中添加新文档，而不是修改旧文档。
    - **新开版本**: 明确选择创建一个全新的版本来包含修改后的文档。
    - **弱化版本概念**: 对用户而言，他们可能更关注“文档”本身，而不是其严格的版本历史。
  - **Qdrant 向量清理问题**: 如果每次更新都创建新文档并标记旧文档为“已删除”，Qdrant 中可能会积累大量“废弃”向量，需要额外的清理机制。
- **影响**:
  - **开发复杂性**: `DocumentService` 中的 `updateDoc` 逻辑需要处理复杂的 Qdrant 交互。
  - **性能问题**: 频繁的删除和插入操作可能影响 Qdrant 的性能。
  - **用户体验**: 严格的版本控制可能不符合所有用户的需求，导致操作不便。

## 3. 解决方案方向 (待讨论)

为了解决上述问题，我们提出了引入“服务层”作为中间抽象层的方案。在此基础上，针对 `Version` 概念，我们有以下几个讨论方向：

1.  **弱化 `Version` 概念，引入“文档状态”**:
    - **思路**: 内部保留 `Version` 作为数据组织机制，但对外接口更简单。`updateDocument` 不直接修改，而是创建新 `Doc` 并标记旧 `Doc` 为“废弃”。
    - **优点**: 简化用户体验，避免 Qdrant 删除。
    - **挑战**: 增加 DB 查询复杂性，Qdrant 中可能存在废弃向量。

2.  **引入“工作区 (Workspace)”或“草稿 (Draft)”概念**:
    - **思路**: 允许用户在“草稿工作区”自由修改，满意后“发布”才创建新 `Version`。
    - **优点**: 提供了更大的灵活性。
    - **挑战**: 增加了系统复杂性，需要管理 `Workspace` 和 `Version` 关系。

3.  **简化 `Version`，使其更像“标签”**:
    - **思路**: `Version` 作为一个可移动的标签，`Doc` 和 `Version` 关系更灵活。
    - **优点**: 极大地简化版本管理。
    - **挑战**: 失去严格版本控制，难以回溯历史，Qdrant 删除问题依然存在。

我们期待就这些问题和解决方案方向进行深入讨论，以确定最适合项目需求和用户体验的架构策略。
